/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * Network type
 */
enum NetworkPrefix {
  /**
   * Mainnet
   */
  Mainnet = 0,
  /**
   * Testnet
   */
  Testnet = 16,
};
typedef uint8_t NetworkPrefix;

/**
 * Type for representing box registers R4 - R9
 */
enum NonMandatoryRegisterId {
  /**
   * id for R4 register
   */
  R4 = 4,
  /**
   * id for R5 register
   */
  R5 = 5,
  /**
   * id for R6 register
   */
  R6 = 6,
  /**
   * id for R7 register
   */
  R7 = 7,
  /**
   * id for R8 register
   */
  R8 = 8,
  /**
   * id for R9 register
   */
  R9 = 9,
};
typedef uint8_t NonMandatoryRegisterId;

/**
 * Address wrapper
 */
typedef struct Address Address;

typedef struct BatchMerkleProof BatchMerkleProof;

/**
 * Block header
 */
typedef struct BlockHeader BlockHeader;

/**
 * Block id
 */
typedef struct BlockId BlockId;

/**
 * Box id (32-byte digest)
 */
typedef struct BoxId BoxId;

/**
 * Selected boxes with change boxes (by [`BoxSelector`])
 */
typedef struct BoxSelection BoxSelection;

/**
 * Box value in nanoERGs with bound checks
 */
typedef struct BoxValue BoxValue;

/**
 * Simple wrapper around a `Vec<u8>`.
 */
typedef struct ByteArray ByteArray;

#if defined(ERGO_REST)
typedef struct CStringCollection CStringCollection;
#endif

typedef struct Collection_BlockHeader Collection_BlockHeader;

typedef struct Collection_BlockId Collection_BlockId;

typedef struct Collection_ByteArray Collection_ByteArray;

typedef struct Collection_DataInput Collection_DataInput;

typedef struct Collection_ErgoBox Collection_ErgoBox;

typedef struct Collection_ErgoBoxAssetsData Collection_ErgoBoxAssetsData;

typedef struct Collection_ErgoBoxCandidate Collection_ErgoBoxCandidate;

typedef struct Collection_Input Collection_Input;

typedef struct Collection_SecretKey Collection_SecretKey;

typedef struct Collection_Token Collection_Token;

typedef struct Collection_UnsignedInput Collection_UnsignedInput;

/**
 * CommitmentHint
 */
typedef struct CommitmentHint CommitmentHint;

/**
 * Ergo constant(evaluated) values
 */
typedef struct Constant Constant;

/**
 * User-defined variables to be put into context
 */
typedef struct ContextExtension ContextExtension;

/**
 * Defines the contract(script) that will be guarding box contents
 */
typedef struct Contract Contract;

/**
 * Inputs, that are used to enrich script context, but won't be spent by the transaction
 */
typedef struct DataInput DataInput;

typedef struct DerivationPath DerivationPath;

/**
 * Ergo box, that is taking part in some transaction on the chain Differs with [`ErgoBoxCandidate`]
 * by added transaction id and an index in the input of that transaction
 */
typedef struct ErgoBox ErgoBox;

/**
 * Pair of <value, tokens> for a box
 */
typedef struct ErgoBoxAssetsData ErgoBoxAssetsData;

/**
 * Contains the same fields as `ErgoBox`, except for transaction id and index, that will be
 * calculated after full transaction formation.  Use `ErgoBoxCandidateBuilder` to create an
 * instance.
 */
typedef struct ErgoBoxCandidate ErgoBoxCandidate;

/**
 * ErgoBoxCandidate builder
 */
typedef struct ErgoBoxCandidateBuilder ErgoBoxCandidateBuilder;

/**
 * Blockchain state (last headers, etc.)
 */
typedef struct ErgoStateContext ErgoStateContext;

/**
 * The root of ErgoScript IR. Serialized instances of this class are self sufficient and can be passed around.
 */
typedef struct ErgoTree ErgoTree;

typedef struct Error Error;

typedef struct ExtPubKey ExtPubKey;

typedef struct ExtSecretKey ExtSecretKey;

/**
 * `HintsBag`
 */
typedef struct HintsBag HintsBag;

/**
 * Signed inputs used in signed transactions
 */
typedef struct Input Input;

/**
 * Merkle Proof type
 */
typedef struct MerkleProof MerkleProof;

typedef struct MnemonicGenerator MnemonicGenerator;

/**
 * A structure representing NiPoPow proof.
 */
typedef struct NipopowProof NipopowProof;

/**
 * A verifier for PoPoW proofs. During its lifetime, it processes many proofs with the aim of
 * deducing at any given point what is the best (sub)chain rooted at the specified genesis.
 */
typedef struct NipopowVerifier NipopowVerifier;

#if defined(ERGO_REST)
typedef struct NodeConf NodeConf;
#endif

#if defined(ERGO_REST)
typedef struct NodeInfo NodeInfo;
#endif

typedef struct PoPowHeader PoPowHeader;

/**
 * Block header with the current `spendingTransaction`, that can be predicted
 * by a miner before its formation
 */
typedef struct PreHeader PreHeader;

/**
 * Propositions list(public keys)
 */
typedef struct Propositions Propositions;

/**
 * Proof of correctness of tx spending
 */
typedef struct ProverResult ProverResult;

/**
 * Represent `reduced` transaction, i.e. unsigned transaction where each unsigned input
 * is augmented with ReducedInput which contains a script reduction result.
 * After an unsigned transaction is reduced it can be signed without context.
 * Thus, it can be serialized and transferred for example to Cold Wallet and signed
 * in an environment where secrets are known.
 * see EIP-19 for more details -
 * <https://github.com/ergoplatform/eips/blob/f280890a4163f2f2e988a0091c078e36912fc531/eip-0019.md>
 */
typedef struct ReducedTransaction ReducedTransaction;

#if defined(ERGO_REST)
/**
 * A "receipt" of the spawned task
 */
typedef struct RequestHandle RequestHandle;
#endif

#if defined(ERGO_REST)
typedef struct RestApiRuntime RestApiRuntime;
#endif

/**
 * Secret key for the prover
 */
typedef struct SecretKey SecretKey;

/**
 * Represents the signature of a signed message
 */
typedef struct SignedMessage SignedMessage;

/**
 * Naive box selector, collects inputs until target balance is reached
 */
typedef struct SimpleBoxSelector SimpleBoxSelector;

/**
 * Token represented with token id paired with its amount
 */
typedef struct Token Token;

/**
 * Token amount with bound checks
 */
typedef struct TokenAmount TokenAmount;

/**
 * Token id (32 byte digest)
 */
typedef struct TokenId TokenId;

/**
 *  * ErgoTransaction is an atomic state transition operation. It destroys Boxes from the state  * and creates new ones. If transaction is spending boxes protected by some non-trivial scripts,  * its inputs should also contain proof of spending correctness - context extension (user-defined  * key-value map) and data inputs (links to existing boxes in the state) that may be used during  * script reduction to crypto, signatures that satisfies the remaining cryptographic protection  * of the script.  * Transactions are not encrypted, so it is possible to browse and view every transaction ever  * collected into a block.
 */
typedef struct Transaction Transaction;

/**
 * TransactionHintsBag
 */
typedef struct TransactionHintsBag TransactionHintsBag;

/**
 * Unsigned transaction builder
 */
typedef struct TxBuilder TxBuilder;

/**
 * Transaction id
 */
typedef struct TxId TxId;

/**
 * Unsigned inputs used in constructing unsigned transactions
 */
typedef struct UnsignedInput UnsignedInput;

/**
 * Unsigned (inputs without proofs) transaction
 */
typedef struct UnsignedTransaction UnsignedTransaction;

/**
 * A collection of secret keys. This simplified signing by matching the secret keys to the correct inputs automatically.
 */
typedef struct Wallet Wallet;

typedef struct Address *AddressPtr;

typedef struct Error *ErrorPtr;

typedef const struct ErgoTree *ConstErgoTreePtr;

typedef const struct Address *ConstAddressPtr;

typedef struct BatchMerkleProof *BatchMerkleProofPtr;

typedef const struct BatchMerkleProof *ConstBatchMerkleProofPtr;

typedef struct BlockHeader *BlockHeaderPtr;

typedef const struct BlockHeader *ConstBlockHeaderPtr;

typedef struct BlockId *BlockIdPtr;

typedef struct Collection_BlockHeader *CollectionPtr_BlockHeader;

typedef CollectionPtr_BlockHeader BlockHeadersPtr;

/**
 * Convenience type to allow us to pass Rust `Option<_>` types through FFI to C side.
 */
typedef struct ReturnOption {
  bool is_some;
  ErrorPtr error;
} ReturnOption;

typedef const struct Collection_BlockHeader *ConstCollectionPtr_BlockHeader;

typedef ConstCollectionPtr_BlockHeader ConstBlockHeadersPtr;

typedef const struct BlockId *ConstBlockIdPtr;

typedef struct Collection_BlockId *CollectionPtr_BlockId;

typedef CollectionPtr_BlockId BlockIdsPtr;

typedef const struct Collection_BlockId *ConstCollectionPtr_BlockId;

typedef ConstCollectionPtr_BlockId ConstBlockIdsPtr;

typedef struct BoxId *BoxIdPtr;

typedef const struct BoxId *ConstBoxIdPtr;

typedef const struct BoxSelection *ConstBoxSelectionPtr;

typedef struct Collection_ErgoBox *CollectionPtr_ErgoBox;

typedef struct Collection_ErgoBoxAssetsData *CollectionPtr_ErgoBoxAssetsData;

typedef struct BoxSelection *BoxSelectionPtr;

typedef const struct Collection_ErgoBox *ConstCollectionPtr_ErgoBox;

typedef const struct Collection_ErgoBoxAssetsData *ConstCollectionPtr_ErgoBoxAssetsData;

typedef const struct BoxValue *ConstBoxValuePtr;

typedef struct BoxValue *BoxValuePtr;

typedef struct ByteArray *ByteArrayPtr;

typedef const struct ByteArray *ConstByteArrayPtr;

typedef struct Collection_ByteArray *CollectionPtr_ByteArray;

typedef CollectionPtr_ByteArray ByteArraysPtr;

typedef const struct Collection_ByteArray *ConstCollectionPtr_ByteArray;

typedef ConstCollectionPtr_ByteArray ConstByteArraysPtr;

#if defined(ERGO_REST)
typedef struct CStringCollection *CStringCollectionPtr;
#endif

typedef struct CommitmentHint *CommitmentHintPtr;

/**
 * Convenience type to allow us to pass Rust enums with `u8` representation through FFI to the C
 * side.
 */
typedef struct ReturnNum_usize {
  /**
   * Returned value. Note that it's only valid if the error field is null!
   */
  uintptr_t value;
  ErrorPtr error;
} ReturnNum_usize;

typedef const struct Constant *ConstConstantPtr;

typedef struct Constant *ConstantPtr;

typedef const struct ErgoBox *ConstErgoBoxPtr;

typedef struct ErgoBox *ErgoBoxPtr;

/**
 * Convenience type to allow us to pass Rust enums with `u8` representation through FFI to the C
 * side.
 */
typedef struct ReturnNum_i32 {
  /**
   * Returned value. Note that it's only valid if the error field is null!
   */
  int32_t value;
  ErrorPtr error;
} ReturnNum_i32;

/**
 * Convenience type to allow us to pass Rust enums with `u8` representation through FFI to the C
 * side.
 */
typedef struct ReturnNum_i64 {
  /**
   * Returned value. Note that it's only valid if the error field is null!
   */
  int64_t value;
  ErrorPtr error;
} ReturnNum_i64;

typedef struct ContextExtension *ContextExtensionPtr;

typedef const struct ContextExtension *ConstContextExtensionPtr;

typedef struct Contract *ContractPtr;

typedef const struct Contract *ConstContractPtr;

typedef struct ErgoTree *ErgoTreePtr;

typedef const struct DataInput *ConstDataInputPtr;

typedef struct DataInput *DataInputPtr;

typedef struct Collection_DataInput *CollectionPtr_DataInput;

typedef CollectionPtr_DataInput DataInputsPtr;

typedef const struct Collection_DataInput *ConstCollectionPtr_DataInput;

typedef ConstCollectionPtr_DataInput ConstDataInputsPtr;

typedef struct DerivationPath *DerivationPathPtr;

typedef const struct DerivationPath *ConstDerivationPathPtr;

typedef struct ErgoBoxAssetsData *ErgoBoxAssetsDataPtr;

typedef const struct ErgoBoxAssetsData *ConstErgoBoxAssetsDataPtr;

typedef CollectionPtr_ErgoBoxAssetsData ErgoBoxAssetsDataListPtr;

typedef ConstCollectionPtr_ErgoBoxAssetsData ConstErgoBoxAssetsDataListPtr;

typedef const struct Collection_Token *ConstCollectionPtr_Token;

typedef struct Collection_Token *CollectionPtr_Token;

typedef const struct ErgoBoxCandidate *ConstErgoBoxCandidatePtr;

typedef struct ErgoBoxCandidateBuilder *ErgoBoxCandidateBuilderPtr;

typedef const struct TokenId *ConstTokenIdPtr;

typedef const struct TokenAmount *ConstTokenAmountPtr;

typedef const struct ErgoBoxCandidateBuilder *ConstErgoBoxCandidateBuilderPtr;

typedef struct ErgoBoxCandidate *ErgoBoxCandidatePtr;

typedef const struct Token *ConstTokenPtr;

typedef struct Collection_ErgoBoxCandidate *CollectionPtr_ErgoBoxCandidate;

typedef CollectionPtr_ErgoBoxCandidate ErgoBoxCandidatesPtr;

typedef const struct Collection_ErgoBoxCandidate *ConstCollectionPtr_ErgoBoxCandidate;

typedef ConstCollectionPtr_ErgoBoxCandidate ConstErgoBoxCandidatesPtr;

typedef const struct TxId *ConstTxIdPtr;

typedef CollectionPtr_ErgoBox ErgoBoxesPtr;

typedef ConstCollectionPtr_ErgoBox ConstErgoBoxesPtr;

typedef struct ErgoStateContext *ErgoStateContextPtr;

typedef const struct ErgoStateContext *ConstErgoStateContextPtr;

typedef const struct PreHeader *ConstPreHeaderPtr;

typedef const struct ExtPubKey *ConstExtPubKeyPtr;

typedef struct ExtPubKey *ExtPubKeyPtr;

typedef const struct ExtSecretKey *ConstExtSecretKeyPtr;

typedef struct ExtSecretKey *ExtSecretKeyPtr;

typedef struct SecretKey *SecretKeyPtr;

typedef struct HintsBag *HintsBagPtr;

typedef const struct CommitmentHint *ConstCommitmentHintPtr;

typedef const struct HintsBag *ConstHintsBagPtr;

typedef const struct Input *ConstInputPtr;

typedef struct Input *InputPtr;

typedef struct ProverResult *ProverResultPtr;

typedef struct Collection_Input *CollectionPtr_Input;

typedef CollectionPtr_Input InputsPtr;

typedef const struct Collection_Input *ConstCollectionPtr_Input;

typedef ConstCollectionPtr_Input ConstInputsPtr;

typedef struct MnemonicGenerator *MnemonicGeneratorPtr;

/**
 * Convenience type to allow us to pass Rust CStrings through FFI to C side (as pointers).
 * Note it is the responsibility of the caller to free the Rust CString.
 * For an example, see MnemonicGenerator in the Swift bindings.
 */
typedef struct ReturnString {
  char *value;
  ErrorPtr error;
} ReturnString;

typedef struct NipopowProof *NipopowProofPtr;

/**
 * Convenience type to allow us to pass Rust bools (with possible error) through FFI to the C side.
 */
typedef struct ReturnBool {
  /**
   * Returned value. Note that it's only valid if the error field is null!
   */
  bool value;
  ErrorPtr error;
} ReturnBool;

typedef const struct NipopowProof *ConstNipopowProofPtr;

typedef struct PoPowHeader *PoPowHeaderPtr;

typedef const struct NipopowVerifier *ConstNipopowVerifierPtr;

typedef struct NipopowVerifier *NipopowVerifierPtr;

#if defined(ERGO_REST)
typedef struct NodeConf *NodeConfPtr;
#endif

#if defined(ERGO_REST)
typedef struct NodeInfo *NodeInfoPtr;
#endif

typedef const struct PoPowHeader *ConstPoPowHeaderPtr;

typedef struct PreHeader *PreHeaderPtr;

typedef struct Propositions *PropositionsPtr;

typedef const struct ProverResult *ConstProverResultPtr;

typedef struct ReducedTransaction *ReducedTransactionPtr;

typedef const struct UnsignedTransaction *ConstUnsignedTransactionPtr;

typedef const struct ReducedTransaction *ConstReducedTransactionPtr;

typedef struct UnsignedTransaction *UnsignedTransactionPtr;

#if defined(ERGO_REST)
typedef struct RestApiRuntime *RestApiRuntimePtr;
#endif

#if defined(ERGO_REST)
/**
 * Callback info for async task
 */
typedef struct CompletionCallback {
  /**
   * Caller's data passed back to the user on the callback
   */
  void *_Nonnull user_data;
  /**
   * User's completion callback function, where the first arg is the above user_data
   * following by either response data or an error
   */
  void (*completion_callback)(void*_Nonnull , const void*, const struct Error*);
  /**
   * User's abort callback, where the argument is the above user_data
   */
  void (*abort_callback)(void*_Nonnull );
} CompletionCallback;
#endif

#if defined(ERGO_REST)
typedef struct RequestHandle *RequestHandlePtr;
#endif

typedef const struct SecretKey *ConstSecretKeyPtr;

typedef struct Collection_SecretKey *CollectionPtr_SecretKey;

typedef CollectionPtr_SecretKey SecretKeysPtr;

typedef const struct Collection_SecretKey *ConstCollectionPtr_SecretKey;

typedef ConstCollectionPtr_SecretKey ConstSecretKeysPtr;

typedef struct SignedMessage *SignedMessagePtr;

typedef struct SimpleBoxSelector *SimpleBoxSelectorPtr;

typedef const struct SimpleBoxSelector *ConstSimpleBoxSelectorPtr;

typedef struct TokenAmount *TokenAmountPtr;

typedef struct Token *TokenPtr;

typedef struct TokenId *TokenIdPtr;

typedef CollectionPtr_Token TokensPtr;

typedef ConstCollectionPtr_Token ConstTokensPtr;

typedef const struct Transaction *ConstTransactionPtr;

typedef const struct Propositions *ConstPropositionsPtr;

typedef struct TransactionHintsBag *TransactionHintsBagPtr;

typedef const struct TransactionHintsBag *ConstTransactionHintsBagPtr;

typedef const struct TxBuilder *ConstTxBuilderPtr;

typedef struct TxBuilder *TxBuilderPtr;

typedef struct Transaction *TransactionPtr;

typedef struct TxId *TxIdPtr;

typedef const struct UnsignedInput *ConstUnsignedInputPtr;

typedef struct UnsignedInput *UnsignedInputPtr;

typedef struct Collection_UnsignedInput *CollectionPtr_UnsignedInput;

typedef CollectionPtr_UnsignedInput UnsignedInputsPtr;

typedef const struct Collection_UnsignedInput *ConstCollectionPtr_UnsignedInput;

typedef ConstCollectionPtr_UnsignedInput ConstUnsignedInputsPtr;

typedef const struct SignedMessage *ConstSignedMessagePtr;

typedef struct Wallet *WalletPtr;

typedef const struct Wallet *ConstWalletPtr;

typedef struct MerkleProof *MerkleProofPtr;

typedef const struct MerkleProof *ConstMerkleProofPtr;

void ergo_lib_address_delete(AddressPtr address);

ErrorPtr ergo_lib_address_from_base58(const char *address_str, AddressPtr *address_out);

ErrorPtr ergo_lib_address_from_ergo_tree(ConstErgoTreePtr ergo_tree_ptr, AddressPtr *address_out);

ErrorPtr ergo_lib_address_from_mainnet(const char *address_str, AddressPtr *address_out);

ErrorPtr ergo_lib_address_from_testnet(const char *address_str, AddressPtr *address_out);

void ergo_lib_address_to_base58(ConstAddressPtr address,
                                NetworkPrefix network_prefix,
                                const char **_address_str);

uint8_t ergo_lib_address_type_prefix(ConstAddressPtr address);

void ergo_lib_batch_merkle_proof_delete(BatchMerkleProofPtr ptr);

ErrorPtr ergo_lib_batch_merkle_proof_from_json(const char *json_str,
                                               BatchMerkleProofPtr *proof_out);

/**
 * Serializes a BatchMerkleProof to json representation
 */
ErrorPtr ergo_lib_batch_merkle_proof_to_json(ConstBatchMerkleProofPtr proof, const char **json_str);

bool ergo_lib_batch_merkle_proof_valid(ConstBatchMerkleProofPtr proof,
                                       const uint8_t *root_hash,
                                       uintptr_t len);

/**
 * Delete `BlockHeader`
 */
void ergo_lib_block_header_delete(BlockHeaderPtr ptr);

bool ergo_lib_block_header_eq(ConstBlockHeaderPtr block_header_ptr_0,
                              ConstBlockHeaderPtr block_header_ptr_1);

/**
 * Parse BlockHeader array from JSON (Node API)
 */
ErrorPtr ergo_lib_block_header_from_json(const char *json_str, BlockHeaderPtr *block_header_out);

/**
 * Get `BlockHeader`s id
 */
void ergo_lib_block_header_id(ConstBlockHeaderPtr block_header_ptr, BlockIdPtr *block_id_out);

/**
 * Copy the contents of `transactions_root` field to `output`. Key assumption: exactly 32 bytes of
 * memory have been allocated at the address pointed-to by `output`.
 */
ErrorPtr ergo_lib_block_header_transactions_root(ConstBlockHeaderPtr block_header_ptr,
                                                 uint8_t *output);

/**
 * Add an element to collection
 */
void ergo_lib_block_headers_add(ConstBlockHeaderPtr element_ptr,
                                BlockHeadersPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_block_headers_delete(BlockHeadersPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_block_headers_get(ConstBlockHeadersPtr collection_ptr,
                                               uintptr_t index,
                                               BlockHeaderPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_block_headers_len(ConstBlockHeadersPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_block_headers_new(BlockHeadersPtr *collection_ptr_out);

/**
 * Delete `BlockId`
 */
void ergo_lib_block_id_delete(BlockIdPtr ptr);

bool ergo_lib_block_id_eq(ConstBlockIdPtr block_id_ptr_0, ConstBlockIdPtr block_id_ptr_1);

/**
 * Convert a hex string into a BlockId
 */
ErrorPtr ergo_lib_block_id_from_str(const char *str, BlockIdPtr *tx_id_out);

/**
 * Add an element to collection
 */
void ergo_lib_block_ids_add(ConstBlockIdPtr element_ptr, BlockIdsPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_block_ids_delete(BlockIdsPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_block_ids_get(ConstBlockIdsPtr collection_ptr,
                                           uintptr_t index,
                                           BlockIdPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_block_ids_len(ConstBlockIdsPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_block_ids_new(BlockIdsPtr *collection_ptr_out);

/**
 * Drop `BoxId`
 */
void ergo_lib_box_id_delete(BoxIdPtr ptr);

bool ergo_lib_box_id_eq(ConstBoxIdPtr box_id_ptr_0, ConstBoxIdPtr box_id_ptr_1);

/**
 * Parse box id (32 byte digest) from base16-encoded string
 */
ErrorPtr ergo_lib_box_id_from_str(const char *box_id_str, BoxIdPtr *box_id_out);

/**
 * Returns byte array (32 bytes) Note: it's imperative that `output` points to a valid block of
 * memory of 32 bytes.
 */
void ergo_lib_box_id_to_bytes(ConstBoxIdPtr box_id_ptr, uint8_t *output);

/**
 * Base16 encoded string
 */
void ergo_lib_box_id_to_str(ConstBoxIdPtr box_id_ptr, const char **_box_id_str);

/**
 * Selected boxes to spend as transaction inputs
 */
void ergo_lib_box_selection_boxes(ConstBoxSelectionPtr box_selection_ptr,
                                  CollectionPtr_ErgoBox *ergo_boxes_out);

/**
 * Selected boxes to use as change
 */
void ergo_lib_box_selection_change(ConstBoxSelectionPtr box_selection_ptr,
                                   CollectionPtr_ErgoBoxAssetsData *change_ergo_boxes_out);

/**
 * Drop `BoxSelection`
 */
void ergo_lib_box_selection_delete(BoxSelectionPtr ptr);

bool ergo_lib_box_selection_eq(ConstBoxSelectionPtr box_selection_ptr_0,
                               ConstBoxSelectionPtr box_selection_ptr_1);

/**
 * Create a selection to easily inject custom selection algorithms
 */
void ergo_lib_box_selection_new(ConstCollectionPtr_ErgoBox ergo_boxes_ptr,
                                ConstCollectionPtr_ErgoBoxAssetsData change_ergo_boxes_ptr,
                                BoxSelectionPtr *box_selection_out);

/**
 * Get value as signed 64-bit long
 */
int64_t ergo_lib_box_value_as_i64(ConstBoxValuePtr box_value_ptr);

/**
 * Drop `BoxValue`
 */
void ergo_lib_box_value_delete(BoxValuePtr ptr);

bool ergo_lib_box_value_eq(ConstBoxValuePtr box_value_ptr_0, ConstBoxValuePtr box_value_ptr_1);

/**
 * Create from i64 with bounds check
 */
ErrorPtr ergo_lib_box_value_from_i64(int64_t amount, BoxValuePtr *box_value_out);

/**
 * Recommended (safe) minimal box value to use in case box size estimation is unavailable.
 * Allows box size upto 2777 bytes with current min box value per byte of 360 nanoERGs
 */
void ergo_lib_box_value_safe_user_min(BoxValuePtr *box_value_out);

/**
 * Create a new box value which is the sum of the arguments, with bounds check.
 */
ErrorPtr ergo_lib_box_value_sum_of(ConstBoxValuePtr box_value0_ptr,
                                   ConstBoxValuePtr box_value1_ptr,
                                   BoxValuePtr *sum_of_out);

/**
 * Number of units inside one ERGO (i.e. one ERG using nano ERG representation)
 */
int64_t ergo_lib_box_value_units_per_ergo(void);

void ergo_lib_byte_array_delete(ByteArrayPtr ptr);

ErrorPtr ergo_lib_byte_array_from_raw_parts(const uint8_t *ptr,
                                            uintptr_t len,
                                            ByteArrayPtr *byte_array_out);

/**
 * Add an element to collection
 */
void ergo_lib_byte_arrays_add(ConstByteArrayPtr element_ptr, ByteArraysPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_byte_arrays_delete(ByteArraysPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_byte_arrays_get(ConstByteArraysPtr collection_ptr,
                                             uintptr_t index,
                                             ByteArrayPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_byte_arrays_len(ConstByteArraysPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_byte_arrays_new(ByteArraysPtr *collection_ptr_out);

#if defined(ERGO_REST)
/**
 * Drop `CStringCollection`
 */
void ergo_lib_c_string_collection_delete(CStringCollectionPtr ptr);
#endif

#if defined(ERGO_REST)
uintptr_t ergo_lib_c_string_collection_get_length(CStringCollectionPtr c_string_collection_ptr);
#endif

#if defined(ERGO_REST)
const char *const *ergo_lib_c_string_collection_get_ptr(CStringCollectionPtr c_string_collection_ptr);
#endif

/**
 * Drop `CommitmentHint`
 */
void ergo_lib_commitment_hint_delete(CommitmentHintPtr ptr);

/**
 * Extract byte array len, returning error if wrong type
 */
struct ReturnNum_usize ergo_lib_constant_bytes_len(ConstConstantPtr constant_ptr);

/**
 * Drop `Constant`
 */
void ergo_lib_constant_delete(ConstantPtr ptr);

bool ergo_lib_constant_eq(ConstConstantPtr constant_ptr_0, ConstConstantPtr constant_ptr_1);

/**
 * Decode from Base16-encoded ErgoTree serialized value
 */
ErrorPtr ergo_lib_constant_from_base16(const char *bytes_ptr, ConstantPtr *constant_out);

/**
 * Create from byte array
 */
ErrorPtr ergo_lib_constant_from_bytes(const uint8_t *bytes_ptr,
                                      uintptr_t len,
                                      ConstantPtr *constant_out);

/**
 * Parse raw EcPoint value from bytes and make ProveDlog constant
 */
ErrorPtr ergo_lib_constant_from_ecpoint_bytes(const uint8_t *bytes_ptr,
                                              uintptr_t len,
                                              ConstantPtr *constant_out);

/**
 * Create from ErgoBox value
 */
void ergo_lib_constant_from_ergo_box(ConstErgoBoxPtr ergo_box_ptr, ConstantPtr *constant_out);

/**
 * Create from i32 value
 */
void ergo_lib_constant_from_i32(int32_t value, ConstantPtr *constant_out);

/**
 * Create from i64
 */
void ergo_lib_constant_from_i64(int64_t value, ConstantPtr *constant_out);

/**
 * Encode as Base16-encoded ErgoTree serialized value or return an error if serialization
 * failed
 */
ErrorPtr ergo_lib_constant_to_base16(ConstConstantPtr constant_ptr, const char **_bytes_str);

/**
 * Extract byte array, returning error if wrong type.  **Key assumption:** enough memory has been
 * allocated at the address pointed-to by `output`. Use `ergo_lib_constant_bytes_len` to
 * determine the length of the byte array.
 */
ErrorPtr ergo_lib_constant_to_bytes(ConstConstantPtr constant_ptr, uint8_t *output);

/**
 * Extract ErgoBox value, returning error if wrong type
 */
ErrorPtr ergo_lib_constant_to_ergo_box(ConstConstantPtr constant_ptr, ErgoBoxPtr *ergo_box_out);

/**
 * Extract i32 value, returning error if wrong type
 */
struct ReturnNum_i32 ergo_lib_constant_to_i32(ConstConstantPtr constant_ptr);

/**
 * Extract i64 value, returning error if wrong type
 */
struct ReturnNum_i64 ergo_lib_constant_to_i64(ConstConstantPtr constant_ptr);

/**
 * Returns the debug representation of the type of the constant as string
 * or return an error if serialization failed
 */
ErrorPtr ergo_lib_constant_type_to_dbg_str(ConstConstantPtr constant_ptr, const char **_bytes_str);

/**
 * Returns the debug representation of the value of the constant as string
 * or return an error if serialization failed
 */
ErrorPtr ergo_lib_constant_value_to_dbg_str(ConstConstantPtr constant_ptr, const char **_bytes_str);

/**
 * Drop `ContextExtension`
 */
void ergo_lib_context_extension_delete(ContextExtensionPtr ptr);

/**
 * Create new empty ContextExtension instance
 */
void ergo_lib_context_extension_empty(ContextExtensionPtr *context_extension_out);

/**
 * Returns all keys (represented as u8 values) in the map
 */
void ergo_lib_context_extension_keys(ConstContextExtensionPtr context_extension_ptr,
                                     uint8_t *output);

/**
 * Returns the number of elements in the collection
 */
uintptr_t ergo_lib_context_extension_len(ConstContextExtensionPtr context_extension_ptr);

/**
 * Compiles a contract from ErgoScript source code
 */
ErrorPtr ergo_lib_contract_compile(const char *source, ContractPtr *contract_out);

/**
 * Drop `Contract`
 */
void ergo_lib_contract_delete(ContractPtr ptr);

bool ergo_lib_contract_eq(ConstContractPtr contract_ptr_0, ConstContractPtr contract_ptr_1);

/**
 * Get the ErgoTree of the contract
 */
void ergo_lib_contract_ergo_tree(ConstContractPtr contract_ptr, ErgoTreePtr *ergo_tree_out);

/**
 * Create new contract from ErgoTree
 */
void ergo_lib_contract_new(ConstErgoTreePtr ergo_tree_ptr, ContractPtr *contract_out);

/**
 * Create new contract that allow spending of the guarded box by a given recipient
 */
ErrorPtr ergo_lib_contract_pay_to_address(ConstAddressPtr address_ptr, ContractPtr *contract_out);

/**
 * Get box id
 */
void ergo_lib_data_input_box_id(ConstDataInputPtr data_input_ptr, BoxIdPtr *box_id_out);

/**
 * Drop `DataInput`
 */
void ergo_lib_data_input_delete(DataInputPtr ptr);

/**
 * Parse box id (32 byte digest)
 */
void ergo_lib_data_input_new(ConstBoxIdPtr box_id_ptr, DataInputPtr *data_input_out);

/**
 * Add an element to collection
 */
void ergo_lib_data_inputs_add(ConstDataInputPtr element_ptr, DataInputsPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_data_inputs_delete(DataInputsPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_data_inputs_get(ConstDataInputsPtr collection_ptr,
                                             uintptr_t index,
                                             DataInputPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_data_inputs_len(ConstDataInputsPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_data_inputs_new(DataInputsPtr *collection_ptr_out);

void ergo_lib_delete_error(ErrorPtr error);

void ergo_lib_delete_string(char *ptr);

/**
 * Drop `DerivationPath`
 */
void ergo_lib_derivation_path_delete(DerivationPathPtr ptr);

/**
 * Returns the length of the derivation path
 */
uintptr_t ergo_lib_derivation_path_depth(ConstDerivationPathPtr derivation_path_ptr);

/**
 * Create derivation path from string
 * String should be in the form of: m/44/429/acc'/0/addr
 */
ErrorPtr ergo_lib_derivation_path_from_str(const char *derivation_path_str,
                                           DerivationPathPtr *derivation_path_out);

/**
 * Create DerivationPath from account index and address indices
 */
ErrorPtr ergo_lib_derivation_path_new(uint32_t account,
                                      const uint32_t *address_indices,
                                      uintptr_t len,
                                      DerivationPathPtr *derivation_path_out);

/**
 * Returns a new derivation path with the last element of the derivation path being increased, e.g. m/1/2 -> m/1/3
 */
ErrorPtr ergo_lib_derivation_path_next(ConstDerivationPathPtr derivation_path_ptr,
                                       DerivationPathPtr *derivation_path_out);

/**
 * Get derivation path as string in the m/44/429/acc'/0/addr format
 */
void ergo_lib_derivation_path_to_str(ConstDerivationPathPtr derivation_path_ptr,
                                     const char **_derivation_path_str);

/**
 * Drop `ErgoBoxAssetsData`
 */
void ergo_lib_ergo_box_assets_data_delete(ErgoBoxAssetsDataPtr ptr);

bool ergo_lib_ergo_box_assets_data_eq(ConstErgoBoxAssetsDataPtr ergo_box_assets_data_ptr_0,
                                      ConstErgoBoxAssetsDataPtr ergo_box_assets_data_ptr_1);

/**
 * Add an element to collection
 */
void ergo_lib_ergo_box_assets_data_list_add(ConstErgoBoxAssetsDataPtr element_ptr,
                                            ErgoBoxAssetsDataListPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_ergo_box_assets_data_list_delete(ErgoBoxAssetsDataListPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_ergo_box_assets_data_list_get(ConstErgoBoxAssetsDataListPtr collection_ptr,
                                                           uintptr_t index,
                                                           ErgoBoxAssetsDataPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_ergo_box_assets_data_list_len(ConstErgoBoxAssetsDataListPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_ergo_box_assets_data_list_new(ErgoBoxAssetsDataListPtr *collection_ptr_out);

/**
 * Create new instance
 */
void ergo_lib_ergo_box_assets_data_new(ConstBoxValuePtr value_ptr,
                                       ConstCollectionPtr_Token tokens_ptr,
                                       ErgoBoxAssetsDataPtr *ergo_box_assets_data_out);

/**
 * Tokens part of the box
 */
void ergo_lib_ergo_box_assets_data_tokens(ConstErgoBoxAssetsDataPtr ergo_box_assets_data_ptr,
                                          CollectionPtr_Token *tokens_out);

/**
 * Value part of the box
 */
void ergo_lib_ergo_box_assets_data_value(ConstErgoBoxAssetsDataPtr ergo_box_assets_data_ptr,
                                         BoxValuePtr *value_out);

/**
 * Get box value in nanoERGs
 */
void ergo_lib_ergo_box_candidate_box_value(ConstErgoBoxCandidatePtr ergo_box_candidate_ptr,
                                           BoxValuePtr *box_value_out);

/**
 * Add given token id and token amount
 */
void ergo_lib_ergo_box_candidate_builder_add_token(ErgoBoxCandidateBuilderPtr builder_mut,
                                                   ConstTokenIdPtr token_id_ptr,
                                                   ConstTokenAmountPtr token_amount_ptr);

/**
 * Build the box candidate
 */
ErrorPtr ergo_lib_ergo_box_candidate_builder_build(ConstErgoBoxCandidateBuilderPtr builder_ptr,
                                                   ErgoBoxCandidatePtr *ergo_box_candidate_out);

/**
 * Calculate serialized box size(in bytes)
 */
struct ReturnNum_usize ergo_lib_ergo_box_candidate_builder_calc_box_size_bytes(ConstErgoBoxCandidateBuilderPtr builder_ptr);

/**
 * Drop `ErgoBoxCandidateBuilder`
 */
void ergo_lib_ergo_box_candidate_builder_delete(ErgoBoxCandidateBuilderPtr ptr);

/**
 * Delete register value(make register empty) for the given register id (R4-R9)
 */
void ergo_lib_ergo_box_candidate_builder_delete_register_value(ErgoBoxCandidateBuilderPtr builder_mut,
                                                               NonMandatoryRegisterId register_id);

/**
 * Get minimal value (per byte of the serialized box size)
 */
uint32_t ergo_lib_ergo_box_candidate_builder_min_box_value_per_byte(ConstErgoBoxCandidateBuilderPtr builder_ptr);

/**
 * Mint token, as defined in <https://github.com/ergoplatform/eips/blob/master/eip-0004.md>
 * `token` - token id(box id of the first input box in transaction) and token amount,
 * `token_name` - token name (will be encoded in R4),
 * `token_desc` - token description (will be encoded in R5),
 * `num_decimals` - number of decimals (will be encoded in R6)
 */
void ergo_lib_ergo_box_candidate_builder_mint_token(ErgoBoxCandidateBuilderPtr builder_mut,
                                                    ConstTokenPtr token_ptr,
                                                    const char *token_name,
                                                    const char *token_desc,
                                                    uintptr_t num_decimals);

/**
 * Create builder with required box parameters:
 * `value` - amount of money associated with the box
 * `contract` - guarding contract, which should be evaluated to true in order
 * to open(spend) this box
 * `creation_height` - height when a transaction containing the box is created.
 * It should not exceed height of the block, containing the transaction with this box.
 */
void ergo_lib_ergo_box_candidate_builder_new(ConstBoxValuePtr value_ptr,
                                             ConstContractPtr contract_ptr,
                                             uint32_t creation_height,
                                             ErgoBoxCandidateBuilderPtr *builder_out);

/**
 * Returns register value for the given register id (R4-R9), or None if the register is empty
 */
struct ReturnOption ergo_lib_ergo_box_candidate_builder_register_value(ConstErgoBoxCandidateBuilderPtr builder_ptr,
                                                                       NonMandatoryRegisterId register_id,
                                                                       ConstantPtr *constant_out);

/**
 * Set minimal value (per byte of the serialized box size)
 */
void ergo_lib_ergo_box_candidate_builder_set_min_box_value_per_byte(ErgoBoxCandidateBuilderPtr builder_mut,
                                                                    uint32_t new_min_value_per_byte);

/**
 * Set register with a given id (R4-R9) to the given value
 */
void ergo_lib_ergo_box_candidate_builder_set_register_value(ErgoBoxCandidateBuilderPtr builder_mut,
                                                            NonMandatoryRegisterId register_id,
                                                            ConstConstantPtr constant_ptr);

/**
 * Set new box value
 */
void ergo_lib_ergo_box_candidate_builder_set_value(ErgoBoxCandidateBuilderPtr builder_mut,
                                                   ConstBoxValuePtr value_ptr);

/**
 * Get box value
 */
void ergo_lib_ergo_box_candidate_builder_value(ConstErgoBoxCandidateBuilderPtr builder_ptr,
                                               BoxValuePtr *value_out);

/**
 * Calculate minimal box value for the current box serialized size(in bytes)
 */
ErrorPtr ergo_lib_ergo_box_candidate_calc_min_box_value(ConstErgoBoxCandidateBuilderPtr builder_ptr,
                                                        BoxValuePtr *value_out);

/**
 * Get box creation height
 */
uint32_t ergo_lib_ergo_box_candidate_creation_height(ConstErgoBoxCandidatePtr ergo_box_candidate_ptr);

/**
 * Drop `ErgoBoxCandidate`
 */
void ergo_lib_ergo_box_candidate_delete(ErgoBoxCandidatePtr ptr);

bool ergo_lib_ergo_box_candidate_eq(ConstErgoBoxCandidatePtr ergo_box_candidate_ptr_0,
                                    ConstErgoBoxCandidatePtr ergo_box_candidate_ptr_1);

/**
 * Get ergo tree for box
 */
void ergo_lib_ergo_box_candidate_ergo_tree(ConstErgoBoxCandidatePtr ergo_box_candidate_ptr,
                                           ErgoTreePtr *ergo_tree_out);

/**
 * Returns value (ErgoTree constant) stored in the register or None if the register is empty
 */
struct ReturnOption ergo_lib_ergo_box_candidate_register_value(ConstErgoBoxCandidatePtr ergo_box_candidate_ptr,
                                                               NonMandatoryRegisterId register_id,
                                                               ConstantPtr *constant_out);

/**
 * Get tokens for box
 */
void ergo_lib_ergo_box_candidate_tokens(ConstErgoBoxCandidatePtr ergo_box_candidate_ptr,
                                        CollectionPtr_Token *tokens_out);

/**
 * Add an element to collection
 */
void ergo_lib_ergo_box_candidates_add(ConstErgoBoxCandidatePtr element_ptr,
                                      ErgoBoxCandidatesPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_ergo_box_candidates_delete(ErgoBoxCandidatesPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_ergo_box_candidates_get(ConstErgoBoxCandidatesPtr collection_ptr,
                                                     uintptr_t index,
                                                     ErgoBoxCandidatePtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_ergo_box_candidates_len(ConstErgoBoxCandidatesPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_ergo_box_candidates_new(ErgoBoxCandidatesPtr *collection_ptr_out);

/**
 * Get box creation height
 */
uint32_t ergo_lib_ergo_box_creation_height(ConstErgoBoxPtr ergo_box_ptr);

/**
 * Drop `ErgoBox`
 */
void ergo_lib_ergo_box_delete(ErgoBoxPtr ptr);

bool ergo_lib_ergo_box_eq(ConstErgoBoxPtr ergo_box_ptr_0, ConstErgoBoxPtr ergo_box_ptr_1);

/**
 * Get ergo tree for box
 */
void ergo_lib_ergo_box_ergo_tree(ConstErgoBoxPtr ergo_box_ptr, ErgoTreePtr *ergo_tree_out);

/**
 * Parse from JSON.  Supports Ergo Node/Explorer API and box values and token amount encoded as
 * strings
 */
ErrorPtr ergo_lib_ergo_box_from_json(const char *json_str, ErgoBoxPtr *ergo_box_out);

/**
 * Get box id
 */
void ergo_lib_ergo_box_id(ConstErgoBoxPtr ergo_box_ptr, BoxIdPtr *box_id_out);

/**
 * Make a new box with:
 * `value` - amount of money associated with the box
 * `contract` - guarding contract, which should be evaluated to true in order
 * to open(spend) this box
 * `creation_height` - height when a transaction containing the box is created.
 * `tx_id` - transaction id in which this box was "created" (participated in outputs)
 * `index` - index (in outputs) in the transaction
 */
ErrorPtr ergo_lib_ergo_box_new(ConstBoxValuePtr value_ptr,
                               uint32_t creation_height,
                               ConstContractPtr contract_ptr,
                               ConstTxIdPtr tx_id_ptr,
                               uint16_t index,
                               ConstCollectionPtr_Token tokens_ptr,
                               ErgoBoxPtr *ergo_box_out);

/**
 * Returns value (ErgoTree constant) stored in the register or None if the register is empty
 */
struct ReturnOption ergo_lib_ergo_box_register_value(ConstErgoBoxPtr ergo_box_ptr,
                                                     NonMandatoryRegisterId register_id,
                                                     ConstantPtr *constant_out);

/**
 * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
 */
ErrorPtr ergo_lib_ergo_box_to_json(ConstErgoBoxPtr ergo_box_ptr,
                                   const char **_json_str);

/**
 * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
 */
ErrorPtr ergo_lib_ergo_box_to_json_eip12(ConstErgoBoxPtr ergo_box_ptr, const char **_json_str);

/**
 * Get tokens for box
 */
void ergo_lib_ergo_box_tokens(ConstErgoBoxPtr ergo_box_ptr, CollectionPtr_Token *tokens_out);

/**
 * Get box value in nanoERGs
 */
void ergo_lib_ergo_box_value(ConstErgoBoxPtr ergo_box_ptr, BoxValuePtr *box_value_out);

/**
 * Add an element to collection
 */
void ergo_lib_ergo_boxes_add(ConstErgoBoxPtr element_ptr, ErgoBoxesPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_ergo_boxes_delete(ErgoBoxesPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_ergo_boxes_get(ConstErgoBoxesPtr collection_ptr,
                                            uintptr_t index,
                                            ErgoBoxPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_ergo_boxes_len(ConstErgoBoxesPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_ergo_boxes_new(ErgoBoxesPtr *collection_ptr_out);

void ergo_lib_ergo_state_context_delete(ErgoStateContextPtr ptr);

bool ergo_lib_ergo_state_context_eq(ConstErgoStateContextPtr ergo_state_context_ptr_0,
                                    ConstErgoStateContextPtr ergo_state_context_ptr_1);

/**
 * Create new context from pre-header
 */
ErrorPtr ergo_lib_ergo_state_context_new(ConstPreHeaderPtr pre_header_ptr,
                                         ConstBlockHeadersPtr headers,
                                         ErgoStateContextPtr *ergo_state_context_out);

/**
 * Determine number of bytes of the serialized ErgoTree
 */
struct ReturnNum_usize ergo_lib_ergo_tree_bytes_len(ConstErgoTreePtr ergo_tree_ptr);

/**
 * Get constants number as stored in serialized ErgoTree or error if the parsing of
 * constants is failed
 */
struct ReturnNum_usize ergo_lib_ergo_tree_constants_len(ConstErgoTreePtr ergo_tree_ptr);

/**
 * Drop `ErgoTree`
 */
void ergo_lib_ergo_tree_delete(ErgoTreePtr ptr);

bool ergo_lib_ergo_tree_eq(ConstErgoTreePtr ergo_tree_ptr_0, ConstErgoTreePtr ergo_tree_ptr_1);

/**
 * Decode from base16 encoded serialized ErgoTree
 */
ErrorPtr ergo_lib_ergo_tree_from_base16_bytes(const char *bytes_ptr, ErgoTreePtr *ergo_tree_out);

/**
 * Decode from encoded serialized ErgoTree
 */
ErrorPtr ergo_lib_ergo_tree_from_bytes(const uint8_t *bytes_ptr,
                                       uintptr_t len,
                                       ErgoTreePtr *ergo_tree_out);

/**
 * Returns constant with given index (as stored in serialized ErgoTree)
 * or None if index is out of bounds
 * or error if constants parsing were failed
 */
struct ReturnOption ergo_lib_ergo_tree_get_constant(ConstErgoTreePtr ergo_tree_ptr,
                                                    uintptr_t index,
                                                    ConstantPtr *constant_out);

/**
 * Serialized proposition expression of SigmaProp type with ConstantPlaceholder nodes instead of
 * Constant nodes. Key assumption: enough memory has been allocated at the address pointed-to by
 * `output`. Use `ergo_lib_ergo_tree_template_bytes_len` to determine the length of the byte
 * array.
 */
ErrorPtr ergo_lib_ergo_tree_template_bytes(ConstErgoTreePtr ergo_tree_ptr, uint8_t *output);

/**
 * Returns the number of bytes of the Serialized proposition expression of SigmaProp type with
 * ConstantPlaceholder nodes instead of Constant nodes.
 */
struct ReturnNum_usize ergo_lib_ergo_tree_template_bytes_len(ConstErgoTreePtr ergo_tree_ptr);

/**
 * Get Base16-encoded serialized bytes
 */
ErrorPtr ergo_lib_ergo_tree_to_base16_bytes(ConstErgoTreePtr ergo_tree_ptr, const char **_str);

/**
 * Convert to serialized bytes. **Key assumption:** enough memory has been allocated at the address
 * pointed-to by `output`. Use `ergo_lib_ergo_tree_bytes_len` to determine the length of the
 * byte array.
 */
ErrorPtr ergo_lib_ergo_tree_to_bytes(ConstErgoTreePtr ergo_tree_ptr, uint8_t *output);

/**
 * Returns new ErgoTree instance with a new constant value for a given index in constants list (as
 * stored in serialized ErgoTree), or an error. Note that the original ErgoTree instance
 * pointed-at by `ergo_tree_ptr` is untouched.
 */
ErrorPtr ergo_lib_ergo_tree_with_constant(ConstErgoTreePtr ergo_tree_ptr,
                                          uintptr_t index,
                                          ConstConstantPtr constant_ptr,
                                          ErgoTreePtr *ergo_tree_out);

char *ergo_lib_error_to_string(ErrorPtr error);

/**
 * Get address for extended public key
 */
void ergo_lib_ext_pub_key_address(ConstExtPubKeyPtr ext_pub_key_ptr, AddressPtr *address_out);

/**
 * Derive a new extended public key from the provided index
 * The index is in the form of soft or hardened indices
 * For example: 4 or 4' respectively
 */
ErrorPtr ergo_lib_ext_pub_key_child(ConstExtPubKeyPtr derive_from_key_ptr,
                                    uint32_t child_index,
                                    ExtPubKeyPtr *ext_pub_key_out);

/**
 * Drop `ExtPubKey`
 */
void ergo_lib_ext_pub_key_delete(ExtPubKeyPtr ptr);

/**
 * Derive a new extended public key from the derivation path
 */
ErrorPtr ergo_lib_ext_pub_key_derive(ConstExtPubKeyPtr ext_pub_key_ptr,
                                     ConstDerivationPathPtr derivation_path_ptr,
                                     ExtPubKeyPtr *ext_pub_key_out);

/**
 * Create ExtPubKey from public key bytes, chain code and derivation path
 */
ErrorPtr ergo_lib_ext_pub_key_new(const uint8_t *public_key_bytes,
                                  const uint8_t *chain_code_ptr,
                                  ConstDerivationPathPtr derivation_path_ptr,
                                  ExtPubKeyPtr *ext_pub_key_out);

/**
 * Derive a new extended secret key from the provided index
 * The index is in the form of soft or hardened indices
 * For example: 4 or 4' respectively
 */
ErrorPtr ergo_lib_ext_secret_key_child(ConstExtSecretKeyPtr secret_key_bytes_ptr,
                                       const char *index_str,
                                       ExtSecretKeyPtr *ext_secret_key_out);

/**
 * Drop `ExtSecretKey`
 */
void ergo_lib_ext_secret_key_delete(ExtSecretKeyPtr ptr);

/**
 * Derive a new extended secret key from the derivation path
 */
ErrorPtr ergo_lib_ext_secret_key_derive(ConstExtSecretKeyPtr ext_secret_key_ptr,
                                        ConstDerivationPathPtr derivation_path_ptr,
                                        ExtSecretKeyPtr *ext_secret_key_out);

/**
 * Derive root extended secret key from seed bytes
 */
ErrorPtr ergo_lib_ext_secret_key_derive_master(const uint8_t *seed,
                                               ExtSecretKeyPtr *ext_secret_key_out);

/**
 * Get secret key for extended secret key
 */
void ergo_lib_ext_secret_key_get_secret_key(ConstExtSecretKeyPtr ext_secret_key_ptr,
                                            SecretKeyPtr *secret_key_out);

/**
 * Create ExtSecretKey from secret key bytes, chain code and derivation path
 */
ErrorPtr ergo_lib_ext_secret_key_new(const uint8_t *secret_key_bytes_ptr,
                                     const uint8_t *chain_code_ptr,
                                     ConstDerivationPathPtr derivation_path_ptr,
                                     ExtSecretKeyPtr *ext_secret_key_out);

/**
 * Get derivation path for extended secret key
 */
void ergo_lib_ext_secret_key_path(ConstExtSecretKeyPtr ext_secret_key_ptr,
                                  DerivationPathPtr *derivation_path_out);

/**
 * The extended public key associated with this secret key
 */
void ergo_lib_ext_secret_key_public_key(ConstExtSecretKeyPtr ext_secret_key_ptr,
                                        ExtPubKeyPtr *ext_pub_key_out);

/**
 * Add commitment hint to the bag
 */
void ergo_lib_hints_bag_add_commitment(HintsBagPtr hints_bag_mut, ConstCommitmentHintPtr hint_ptr);

/**
 * Drop `HintsBag`
 */
void ergo_lib_hints_bag_delete(HintsBagPtr ptr);

/**
 * Empty HintsBag
 */
void ergo_lib_hints_bag_empty(HintsBagPtr *hints_bag_out);

/**
 * Get commitment
 */
struct ReturnOption ergo_lib_hints_bag_get(ConstHintsBagPtr hints_bag_ptr,
                                           uintptr_t index,
                                           CommitmentHintPtr *hint_out);

/**
 * Length of HintsBag
 */
uintptr_t ergo_lib_hints_bag_len(ConstHintsBagPtr hints_bag_ptr);

/**
 * Get box id
 */
void ergo_lib_input_box_id(ConstInputPtr input_ptr, BoxIdPtr *box_id_out);

/**
 * Drop `Input`
 */
void ergo_lib_input_delete(InputPtr ptr);

/**
 * Get spending proof
 */
void ergo_lib_input_spending_proof(ConstInputPtr input_ptr, ProverResultPtr *prover_result_out);

/**
 * Add an element to collection
 */
void ergo_lib_inputs_add(ConstInputPtr element_ptr, InputsPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_inputs_delete(InputsPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_inputs_get(ConstInputsPtr collection_ptr,
                                        uintptr_t index,
                                        InputPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_inputs_len(ConstInputsPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_inputs_new(InputsPtr *collection_ptr_out);

/**
 * Create new MnemonicGenerator instance
 */
ErrorPtr ergo_lib_mnemonic_generator(const char *language,
                                     uint32_t strength,
                                     MnemonicGeneratorPtr *mnemonic_generator_out);

/**
 * Free a previously-created CString. Intended to be paired with one of the
 * mnemonic generation functions. Called by the client.
 */
void ergo_lib_mnemonic_generator_free_mnemonic(char *mnemonic);

/**
 * Generate mnemonic sentence using random entropy
 */
struct ReturnString ergo_lib_mnemonic_generator_generate(MnemonicGeneratorPtr mnemonic_generator_ptr);

/**
 * Generate mnemonic sentence using provided entropy
 */
struct ReturnString ergo_lib_mnemonic_generator_generate_from_entropy(MnemonicGeneratorPtr mnemonic_generator_ptr,
                                                                      uint8_t *entropy,
                                                                      uintptr_t len);

/**
 * Delete `NipopowProof`
 */
void ergo_lib_nipopow_proof_delete(NipopowProofPtr ptr);

/**
 * Parse from JSON.
 */
ErrorPtr ergo_lib_nipopow_proof_from_json(const char *json_str, NipopowProofPtr *nipopow_proof_out);

/**
 * Implementation of the  algorithm from [`KMZ17`], see Algorithm 4
 *
 * [`KMZ17`]: https://fc20.ifca.ai/preproceedings/74.pdf
 */
struct ReturnBool ergo_lib_nipopow_proof_is_better_than(ConstNipopowProofPtr nipopow_proof_ptr,
                                                        ConstNipopowProofPtr other_nipopow_proof_ptr);

/**
 * Get suffix head
 */
void ergo_lib_nipopow_proof_suffix_head(ConstNipopowProofPtr nipopow_proof_ptr,
                                        PoPowHeaderPtr *suffix_head_out);

/**
 * JSON representation as text
 */
ErrorPtr ergo_lib_nipopow_proof_to_json(ConstNipopowProofPtr nipopow_proof_ptr,
                                        const char **_json_str);

/**
 * Returns chain of `BlockHeader`s from the best proof.
 */
void ergo_lib_nipopow_verifier_best_chain(ConstNipopowVerifierPtr nipopow_verifier_ptr,
                                          CollectionPtr_BlockHeader *best_chain_out);

/**
 * Returns the best proof.
 */
struct ReturnOption ergo_lib_nipopow_verifier_best_proof(ConstNipopowVerifierPtr nipopow_verifier_ptr,
                                                         NipopowProofPtr *best_proof_out);

/**
 * Delete `NipopowVerifier`
 */
void ergo_lib_nipopow_verifier_delete(NipopowVerifierPtr ptr);

/**
 * Create new `NipopowVerifier` instance
 */
void ergo_lib_nipopow_verifier_new(ConstBlockIdPtr genesis_block_id_ptr,
                                   NipopowVerifierPtr *nipopow_verifier_out);

/**
 * Process given proof
 */
ErrorPtr ergo_lib_nipopow_verifier_process(NipopowVerifierPtr nipopow_verifier_ptr,
                                           ConstNipopowProofPtr nipopow_proof_ptr);

#if defined(ERGO_REST)
/**
 * Drop `NodeConf`
 */
void ergo_lib_node_conf_delete(NodeConfPtr ptr);
#endif

#if defined(ERGO_REST)
/**
 * Parse IP address and port from string
 */
ErrorPtr ergo_lib_node_conf_from_addr(const char *addr_str, NodeConfPtr *ptr_out);
#endif

#if defined(ERGO_REST)
/**
 * Drop `NodeInfo`
 */
void ergo_lib_node_info_delete(NodeInfoPtr ptr);
#endif

#if defined(ERGO_REST)
/**
 * Node's name
 */
void ergo_lib_node_info_get_name(NodeInfoPtr ptr, const char **name_str);
#endif

#if defined(ERGO_REST)
/**
 * Returns true iff the ergo node is at least v4.0.28. This is important since nipopow proofs only
 * work correctly from this version onwards.
 */
bool ergo_lib_node_info_is_at_least_version_4_0_100(NodeInfoPtr node_info_ptr);
#endif

bool ergo_lib_po_pow_header_eq(ConstPoPowHeaderPtr po_pow_header_ptr_0,
                               ConstPoPowHeaderPtr po_pow_header_ptr_1);

bool ergo_lib_popow_header_check_interlinks_proof(ConstPoPowHeaderPtr popow_header_ptr);

void ergo_lib_popow_header_delete(PoPowHeaderPtr ptr);

ErrorPtr ergo_lib_popow_header_from_json(const char *json_str, PoPowHeaderPtr *header_out);

ErrorPtr ergo_lib_popow_header_get_header(ConstPoPowHeaderPtr popow_header,
                                          BlockHeaderPtr *header_out);

ErrorPtr ergo_lib_popow_header_get_interlinks(ConstPoPowHeaderPtr popow_header,
                                              BlockIdsPtr *interlinks_out);

ErrorPtr ergo_lib_popow_header_get_interlinks_proof(ConstPoPowHeaderPtr popow_header,
                                                    BatchMerkleProofPtr *header_out);

ErrorPtr ergo_lib_popow_header_to_json(ConstPoPowHeaderPtr header, const char **_json_str);

bool ergo_lib_pre_header_eq(ConstPreHeaderPtr pre_header_ptr_0, ConstPreHeaderPtr pre_header_ptr_1);

/**
 * Drop `PreHeader`
 */
void ergo_lib_preheader_delete(PreHeaderPtr ptr);

/**
 * Create instance using data from block header
 */
void ergo_lib_preheader_from_block_header(ConstBlockHeaderPtr block_header,
                                          PreHeaderPtr *preheader_out);

/**
 * Adding new proposition
 */
ErrorPtr ergo_lib_propositions_add_proposition_from_bytes(PropositionsPtr propositions_mut,
                                                          const uint8_t *bytes_ptr,
                                                          uintptr_t len);

/**
 * Drop `Propositions`
 */
void ergo_lib_propositions_delete(PropositionsPtr ptr);

/**
 * Create empty proposition holder
 */
void ergo_lib_propositions_new(PropositionsPtr *propositions_out);

/**
 * Get extension
 */
void ergo_lib_prover_result_context_extension(ConstProverResultPtr prover_result_ptr,
                                              ContextExtensionPtr *context_extension_out);

/**
 * Drop `ProverResult`
 */
void ergo_lib_prover_result_delete(ProverResultPtr ptr);

/**
 * Get proof. Key assumption: enough memory has been allocated at the address pointed-to by
 * `output`. Use `ergo_lib_prover_result_proof_len` to determine the length of the byte
 * array.
 */
void ergo_lib_prover_result_proof(ConstProverResultPtr prover_result_ptr, uint8_t *output);

/**
 * Return the number of bytes that make up the proof.
 */
uintptr_t ergo_lib_prover_result_proof_len(ConstProverResultPtr prover_result_ptr);

/**
 * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
 */
ErrorPtr ergo_lib_prover_result_to_json(ConstProverResultPtr prover_result_ptr,
                                        const char **_json_str);

/**
 * Drop `ReducedTransaction`
 */
void ergo_lib_reduced_tx_delete(ReducedTransactionPtr ptr);

/**
 * Returns `reduced` transaction, i.e. unsigned transaction where each unsigned input
 * is augmented with ReducedInput which contains a script reduction result.
 */
ErrorPtr ergo_lib_reduced_tx_from_unsigned_tx(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                              ConstCollectionPtr_ErgoBox boxes_to_spend_ptr,
                                              ConstCollectionPtr_ErgoBox data_boxes_ptr,
                                              ConstErgoStateContextPtr state_context_ptr,
                                              ReducedTransactionPtr *reduced_tx_out);

/**
 * Returns the unsigned transation
 */
void ergo_lib_reduced_tx_unsigned_tx(ConstReducedTransactionPtr reduced_tx_ptr,
                                     UnsignedTransactionPtr *unsigned_tx_out);

#if defined(ERGO_REST)
/**
 * GET on /blocks/{header_id}/proofFor/{tx_id} to request the merkle proof for a given transaction
 * that belongs to the given header ID.
 */
ErrorPtr ergo_lib_rest_api_node_get_blocks_header_id_proof_for_tx_id(RestApiRuntimePtr runtime_ptr,
                                                                     NodeConfPtr node_conf_ptr,
                                                                     struct CompletionCallback callback,
                                                                     RequestHandlePtr *request_handle_out,
                                                                     ConstBlockIdPtr header_id_ptr,
                                                                     ConstTxIdPtr tx_id_ptr);
#endif

#if defined(ERGO_REST)
/**
 * GET on /blocks/{blockId}/header endpoint
 */
ErrorPtr ergo_lib_rest_api_node_get_header(RestApiRuntimePtr runtime_ptr,
                                           NodeConfPtr node_conf_ptr,
                                           struct CompletionCallback callback,
                                           RequestHandlePtr *request_handle_out,
                                           ConstBlockIdPtr header_id_ptr);
#endif

#if defined(ERGO_REST)
/**
 * GET on /info endpoint
 */
ErrorPtr ergo_lib_rest_api_node_get_info(RestApiRuntimePtr runtime_ptr,
                                         NodeConfPtr node_conf_ptr,
                                         struct CompletionCallback callback,
                                         RequestHandlePtr *request_handle_out);
#endif

#if defined(ERGO_REST)
/**
 * GET on /nipopow/proof/{minChainLength}/{suffixLength}/{headerId} endpoint
 */
ErrorPtr ergo_lib_rest_api_node_get_nipopow_proof_by_header_id(RestApiRuntimePtr runtime_ptr,
                                                               NodeConfPtr node_conf_ptr,
                                                               struct CompletionCallback callback,
                                                               RequestHandlePtr *request_handle_out,
                                                               uint32_t min_chain_length,
                                                               uint32_t suffix_len,
                                                               ConstBlockIdPtr header_id_ptr);
#endif

#if defined(ERGO_REST)
/**
 * GET on /peer_discovery endpoint
 */
ErrorPtr ergo_lib_rest_api_node_peer_discovery(RestApiRuntimePtr runtime_ptr,
                                               struct CompletionCallback callback,
                                               RequestHandlePtr *request_handle_out,
                                               const char *const *seeds_ptr,
                                               uintptr_t num_seeds,
                                               uint16_t max_parallel_requests,
                                               uint32_t timeout_sec);
#endif

#if defined(ERGO_REST)
/**
 * Abort the request
 */
ErrorPtr ergo_lib_rest_api_request_handle_abort(RequestHandlePtr handle_ptr);
#endif

#if defined(ERGO_REST)
/**
 * Drop request handle
 */
void ergo_lib_rest_api_request_handle_delete(RequestHandlePtr ptr);
#endif

#if defined(ERGO_REST)
/**
 * Create tokio runtime instance
 */
ErrorPtr ergo_lib_rest_api_runtime_create(RestApiRuntimePtr *runtime_out);
#endif

#if defined(ERGO_REST)
/**
 * Drop tokio runtime
 */
void ergo_lib_rest_api_runtime_delete(RestApiRuntimePtr ptr);
#endif

/**
 * Drop `SecretKey`
 */
void ergo_lib_secret_key_delete(SecretKeyPtr ptr);

/**
 * Parse dlog secret key from bytes (SEC-1-encoded scalar)
 */
ErrorPtr ergo_lib_secret_key_from_bytes(const uint8_t *bytes_ptr, SecretKeyPtr *secret_key_out);

/**
 * Generate random key
 */
void ergo_lib_secret_key_generate_random(SecretKeyPtr *secret_key_out);

/**
 * Address (encoded public image)
 */
void ergo_lib_secret_key_get_address(ConstSecretKeyPtr secret_key_ptr, AddressPtr *address_out);

/**
 * Encode from a serialized key. Key assumption: 32 bytes must be allocated at the address
 * pointed-to by `output`.
 */
void ergo_lib_secret_key_to_bytes(ConstSecretKeyPtr secret_key_ptr, uint8_t *output);

/**
 * Add an element to collection
 */
void ergo_lib_secret_keys_add(ConstSecretKeyPtr element_ptr, SecretKeysPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_secret_keys_delete(SecretKeysPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_secret_keys_get(ConstSecretKeysPtr collection_ptr,
                                             uintptr_t index,
                                             SecretKeyPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_secret_keys_len(ConstSecretKeysPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_secret_keys_new(SecretKeysPtr *collection_ptr_out);

/**
 * Drop `SignedMessage`
 */
void ergo_lib_signed_message_delete(SignedMessagePtr ptr);

/**
 * Drop `SimpleBoxSelector`
 */
void ergo_lib_simple_box_selector_delete(SimpleBoxSelectorPtr ptr);

/**
 * Naive box selector, collects inputs until target balance is reached
 */
void ergo_lib_simple_box_selector_new(SimpleBoxSelectorPtr *simple_box_selector_out);

/**
 * Selects inputs to satisfy target balance and tokens.
 * `inputs` - available inputs (returns an error, if empty),
 * `target_balance` - coins (in nanoERGs) needed,
 * `target_tokens` - amount of tokens needed.
 * Returns selected inputs and box assets(value+tokens) with change.
 */
ErrorPtr ergo_lib_simple_box_selector_select(ConstSimpleBoxSelectorPtr simple_box_selector_ptr,
                                             ConstCollectionPtr_ErgoBox inputs_ptr,
                                             ConstBoxValuePtr target_balance_ptr,
                                             ConstCollectionPtr_Token target_tokens_ptr,
                                             BoxSelectionPtr *box_selection_out);

/**
 * Get value as signed 64-bit long
 */
int64_t ergo_lib_token_amount_as_i64(ConstTokenAmountPtr token_amount_ptr);

/**
 * Drop `TokenAmount`
 */
void ergo_lib_token_amount_delete(TokenAmountPtr ptr);

bool ergo_lib_token_amount_eq(ConstTokenAmountPtr token_amount_ptr_0,
                              ConstTokenAmountPtr token_amount_ptr_1);

/**
 * Create from i64 with bounds check
 */
ErrorPtr ergo_lib_token_amount_from_i64(int64_t amount, TokenAmountPtr *token_amount_out);

/**
 * Drop `Token`
 */
void ergo_lib_token_delete(TokenPtr ptr);

bool ergo_lib_token_eq(ConstTokenPtr token_ptr_0, ConstTokenPtr token_ptr_1);

/**
 * Get token amount
 */
void ergo_lib_token_get_amount(ConstTokenPtr token_ptr, TokenAmountPtr *token_amount_out);

/**
 * Get token id
 */
void ergo_lib_token_get_id(ConstTokenPtr token_ptr, TokenIdPtr *token_id_out);

/**
 * Drop `TokenId`
 */
void ergo_lib_token_id_delete(TokenIdPtr ptr);

bool ergo_lib_token_id_eq(ConstTokenIdPtr token_id_ptr_0, ConstTokenIdPtr token_id_ptr_1);

/**
 * Create token id from ergo box id (32 byte digest)
 */
void ergo_lib_token_id_from_box_id(ConstBoxIdPtr box_id_ptr, TokenIdPtr *token_id_out);

/**
 * Parse token id (32 byte digest) from base16-encoded string
 */
ErrorPtr ergo_lib_token_id_from_str(const char *bytes_ptr, TokenIdPtr *token_id_out);

/**
 * Base16 encoded string
 */
void ergo_lib_token_id_to_str(ConstTokenIdPtr token_id_ptr, const char **_str);

/**
 * Create a token with given token id and amount
 */
void ergo_lib_token_new(ConstTokenIdPtr token_id_ptr,
                        ConstTokenAmountPtr token_amount_ptr,
                        TokenPtr *token_out);

/**
 * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
 */
ErrorPtr ergo_lib_token_to_json_eip12(ConstTokenPtr token_ptr, const char **_json_str);

/**
 * Add an element to collection
 */
void ergo_lib_tokens_add(ConstTokenPtr element_ptr, TokensPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_tokens_delete(TokensPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_tokens_get(ConstTokensPtr collection_ptr,
                                        uintptr_t index,
                                        TokenPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_tokens_len(ConstTokensPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_tokens_new(TokensPtr *collection_ptr_out);

/**
 * Extract hints from signed transaction
 */
ErrorPtr ergo_lib_transaction_extract_hints(ConstTransactionPtr signed_transaction_ptr,
                                            ConstErgoStateContextPtr state_context_ptr,
                                            ConstCollectionPtr_ErgoBox boxes_to_spend_ptr,
                                            ConstCollectionPtr_ErgoBox data_boxes_ptr,
                                            ConstPropositionsPtr real_propositions_ptr,
                                            ConstPropositionsPtr simulated_propositions_ptr,
                                            TransactionHintsBagPtr *transaction_hints_bag_out);

/**
 * Adding hints for input
 */
void ergo_lib_transaction_hints_bag_add_hints_for_input(TransactionHintsBagPtr transaction_hints_bag_mut,
                                                        uintptr_t index,
                                                        ConstHintsBagPtr hints_bag_ptr);

/**
 * Get HintsBag corresponding to input index
 */
void ergo_lib_transaction_hints_bag_all_hints_for_input(ConstTransactionHintsBagPtr transaction_hints_bag_ptr,
                                                        uintptr_t index,
                                                        HintsBagPtr *hints_bag_out);

/**
 * Drop `TransactionHintsBag`
 */
void ergo_lib_transaction_hints_bag_delete(TransactionHintsBagPtr ptr);

/**
 * Empty TransactionHintsBag
 */
void ergo_lib_transaction_hints_bag_empty(TransactionHintsBagPtr *transaction_hints_bag_out);

/**
 * Get box selection
 */
void ergo_lib_tx_builder_box_selection(ConstTxBuilderPtr tx_builder_ptr,
                                       BoxSelectionPtr *box_selection_out);

/**
 * Build the unsigned transaction
 */
ErrorPtr ergo_lib_tx_builder_build(ConstTxBuilderPtr tx_builder_ptr,
                                   UnsignedTransactionPtr *unsigned_transaction_out);

/**
 * Get change address
 */
void ergo_lib_tx_builder_change_address(ConstTxBuilderPtr tx_builder_ptr, AddressPtr *address_out);

/**
 * Get current height
 */
uint32_t ergo_lib_tx_builder_current_height(ConstTxBuilderPtr tx_builder_ptr);

/**
 * Get data inputs
 */
void ergo_lib_tx_builder_data_inputs(ConstTxBuilderPtr tx_builder_ptr,
                                     CollectionPtr_DataInput *data_inputs_out);

/**
 * Drop `TxBuilder`
 */
void ergo_lib_tx_builder_delete(TxBuilderPtr ptr);

/**
 * Get fee amount
 */
void ergo_lib_tx_builder_fee_amount(ConstTxBuilderPtr tx_builder_ptr, BoxValuePtr *value_out);

/**
 * Creates new TxBuilder
 * `box_selection` - selected input boxes
 * `output_candidates` - output boxes to be "created" in this transaction,
 * `current_height` - chain height that will be used in additionally created boxes (change, miner's fee, etc.),
 * `fee_amount` - miner's fee,
 * `change_address` - change (inputs - outputs) will be sent to this address,
 * will be given to miners,
 */
void ergo_lib_tx_builder_new(ConstBoxSelectionPtr box_selection_ptr,
                             ConstCollectionPtr_ErgoBoxCandidate output_candidates_ptr,
                             uint32_t current_height,
                             ConstBoxValuePtr fee_amount_ptr,
                             ConstAddressPtr change_address_ptr,
                             TxBuilderPtr *tx_builder_out);

/**
 * Get outputs EXCLUDING fee and change
 */
void ergo_lib_tx_builder_output_candidates(ConstTxBuilderPtr tx_builder_ptr,
                                           CollectionPtr_ErgoBoxCandidate *output_candidates_out);

/**
 * Set context extension for a given input
 */
void ergo_lib_tx_builder_set_context_extension(TxBuilderPtr tx_builder_mut,
                                               BoxIdPtr box_id_ptr,
                                               ContextExtensionPtr ctx_ext_ptr);

/**
 * Set transaction's data inputs
 */
void ergo_lib_tx_builder_set_data_inputs(TxBuilderPtr tx_builder_mut,
                                         ConstCollectionPtr_DataInput data_inputs_ptr);

/**
 * Permits the burn of the given token amount, i.e. allows this token amount to be omitted in the outputs
 */
void ergo_lib_tx_builder_set_token_burn_permit(TxBuilderPtr tx_builder_mut,
                                               ConstCollectionPtr_Token target_tokens_ptr);

/**
 * Suggested transaction fee (semi-default value used across wallets and dApps as of Oct 2020)
 */
void ergo_lib_tx_builder_suggested_tx_fee(BoxValuePtr *value_out);

void ergo_lib_tx_data_inputs(ConstTransactionPtr tx_ptr, DataInputsPtr *data_inputs_out);

/**
 * Drop `Transaction`
 */
void ergo_lib_tx_delete(TransactionPtr ptr);

/**
 * Parse from JSON. Supports Ergo Node/Explorer API and box values and token amount encoded as
 * strings
 */
ErrorPtr ergo_lib_tx_from_json(const char *json_str, TransactionPtr *tx_out);

/**
 * Create Transaction from UnsignedTransaction and an array of proofs in the same order as
 * UnsignedTransaction.inputs with empty proof indicated with empty byte array
 */
ErrorPtr ergo_lib_tx_from_unsigned_tx(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                      ConstByteArraysPtr proofs_ptr,
                                      TransactionPtr *tx_out);

/**
 * Get id for transaction
 */
void ergo_lib_tx_id(ConstTransactionPtr tx_ptr, TxIdPtr *tx_id_out);

/**
 * Drop `TxId`
 */
void ergo_lib_tx_id_delete(TxIdPtr ptr);

bool ergo_lib_tx_id_eq(ConstTxIdPtr tx_id_ptr_0, ConstTxIdPtr tx_id_ptr_1);

/**
 * Convert a hex string into a TxId
 */
ErrorPtr ergo_lib_tx_id_from_str(const char *str, TxIdPtr *tx_id_out);

/**
 * Get the tx id as bytes
 */
ErrorPtr ergo_lib_tx_id_to_str(ConstTxIdPtr tx_id_ptr, const char **_str);

void ergo_lib_tx_inputs(ConstTransactionPtr tx_ptr, InputsPtr *inputs_out);

void ergo_lib_tx_output_candidates(ConstTransactionPtr tx_ptr,
                                   ErgoBoxCandidatesPtr *ergo_box_candidates_out);

void ergo_lib_tx_outputs(ConstTransactionPtr tx_ptr, ErgoBoxesPtr *ergo_box_out);

/**
 * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
 */
ErrorPtr ergo_lib_tx_to_json(ConstTransactionPtr tx_ptr,
                             const char **_json_str);

/**
 * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
 */
ErrorPtr ergo_lib_tx_to_json_eip12(ConstTransactionPtr tx_ptr, const char **_json_str);

/**
 * Get box id
 */
void ergo_lib_unsigned_input_box_id(ConstUnsignedInputPtr unsigned_input_ptr, BoxIdPtr *box_id_out);

/**
 * Get extension
 */
void ergo_lib_unsigned_input_context_extension(ConstUnsignedInputPtr unsigned_input_ptr,
                                               ContextExtensionPtr *context_extension_out);

/**
 * Drop `UnsignedInput`
 */
void ergo_lib_unsigned_input_delete(UnsignedInputPtr ptr);

/**
 * Add an element to collection
 */
void ergo_lib_unsigned_inputs_add(ConstUnsignedInputPtr element_ptr,
                                  UnsignedInputsPtr collection_ptr_out);

/**
 * Delete an existing collection
 */
void ergo_lib_unsigned_inputs_delete(UnsignedInputsPtr ptr_out);

/**
 * Returns element at position `index` of an existing collection
 */
struct ReturnOption ergo_lib_unsigned_inputs_get(ConstUnsignedInputsPtr collection_ptr,
                                                 uintptr_t index,
                                                 UnsignedInputPtr *element_ptr_out);

/**
 * Returns length of an existing collection
 */
uintptr_t ergo_lib_unsigned_inputs_len(ConstUnsignedInputsPtr collection_ptr);

/**
 * Create a new empty collection
 */
void ergo_lib_unsigned_inputs_new(UnsignedInputsPtr *collection_ptr_out);

/**
 * Data inputs for transaction
 */
void ergo_lib_unsigned_tx_data_inputs(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                      DataInputsPtr *data_inputs_out);

/**
 * Drop `UnsignedTransaction`
 */
void ergo_lib_unsigned_tx_delete(UnsignedTransactionPtr ptr);

/**
 * Parse from JSON. Supports Ergo Node/Explorer API and box values and token amount encoded as
 * strings
 */
ErrorPtr ergo_lib_unsigned_tx_from_json(const char *json_str,
                                        UnsignedTransactionPtr *unsigned_tx_out);

/**
 * Get id for transaction
 */
void ergo_lib_unsigned_tx_id(ConstUnsignedTransactionPtr unsigned_tx_ptr, TxIdPtr *tx_id_out);

/**
 * Inputs for transaction
 */
void ergo_lib_unsigned_tx_inputs(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                 UnsignedInputsPtr *unsigned_inputs_out);

/**
 * Output candidates for transaction
 */
void ergo_lib_unsigned_tx_output_candidates(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                            ErgoBoxCandidatesPtr *ergo_box_candidates_out);

/**
 * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
 */
ErrorPtr ergo_lib_unsigned_tx_to_json(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                      const char **_json_str);

/**
 * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
 */
ErrorPtr ergo_lib_unsigned_tx_to_json_eip12(ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                            const char **_json_str);

/**
 * Verify that the signature is presented to satisfy SigmaProp conditions.
 */
struct ReturnBool ergo_lib_verify_signature(ConstAddressPtr address_ptr,
                                            const uint8_t *message_ptr,
                                            uintptr_t message_length,
                                            ConstSignedMessagePtr signed_message_ptr);

ErrorPtr ergo_lib_wallet_add_secret(WalletPtr wallet_ptr, struct SecretKey *secret_key_ptr);

/**
 * Drop `Wallet`
 */
void ergo_lib_wallet_delete(WalletPtr ptr);

/**
 * Create `Wallet` instance loading secret key from mnemonic
 * Returns Err if a DlogSecretKey cannot be parsed from the provided phrase
 */
ErrorPtr ergo_lib_wallet_from_mnemonic(const char *mnemonic_phrase,
                                       const char *mnemonic_pass,
                                       WalletPtr *wallet_out);

/**
 * Create `Wallet` from secrets
 */
void ergo_lib_wallet_from_secrets(ConstCollectionPtr_SecretKey secret_keys_ptr,
                                  WalletPtr *wallet_out);

/**
 * Generate Commitments for unsigned tx
 */
ErrorPtr ergo_lib_wallet_generate_commitments(ConstWalletPtr wallet_ptr,
                                              ConstErgoStateContextPtr state_context_ptr,
                                              ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                              ConstCollectionPtr_ErgoBox boxes_to_spend_ptr,
                                              ConstCollectionPtr_ErgoBox data_boxes_ptr,
                                              TransactionHintsBagPtr *transaction_hints_bag_out);

/**
 * Generate Commitments for reduced transaction
 */
ErrorPtr ergo_lib_wallet_generate_commitments_for_reduced_transaction(ConstWalletPtr wallet_ptr,
                                                                      ConstReducedTransactionPtr reduced_tx_ptr,
                                                                      TransactionHintsBagPtr *transaction_hints_bag_out);

/**
 * Sign an arbitrary message using a P2PK address
 */
ErrorPtr ergo_lib_wallet_sign_message_using_p2pk(ConstWalletPtr wallet_ptr,
                                                 ConstAddressPtr address_ptr,
                                                 const uint8_t *message_ptr,
                                                 uintptr_t message_length,
                                                 SignedMessagePtr *signed_message_out);

/**
 * Signs a reduced transaction (generating proofs for inputs)
 */
ErrorPtr ergo_lib_wallet_sign_reduced_transaction(ConstWalletPtr wallet_ptr,
                                                  ConstReducedTransactionPtr reduced_tx_ptr,
                                                  TransactionPtr *transaction_out);

/**
 * Signs a multi signature reduced transaction
 */
ErrorPtr ergo_lib_wallet_sign_reduced_transaction_multi(ConstWalletPtr wallet_ptr,
                                                        ConstReducedTransactionPtr reduced_tx_ptr,
                                                        ConstTransactionHintsBagPtr tx_hints_ptr,
                                                        TransactionPtr *transaction_out);

/**
 * Signs a transaction
 */
ErrorPtr ergo_lib_wallet_sign_transaction(ConstWalletPtr wallet_ptr,
                                          ConstErgoStateContextPtr state_context_ptr,
                                          ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                          ConstCollectionPtr_ErgoBox boxes_to_spend_ptr,
                                          ConstCollectionPtr_ErgoBox data_boxes_ptr,
                                          TransactionPtr *transaction_out);

/**
 * Signs a multi signature transaction
 */
ErrorPtr ergo_lib_wallet_sign_transaction_multi(ConstWalletPtr wallet_ptr,
                                                ConstErgoStateContextPtr state_context_ptr,
                                                ConstUnsignedTransactionPtr unsigned_tx_ptr,
                                                ConstCollectionPtr_ErgoBox boxes_to_spend_ptr,
                                                ConstCollectionPtr_ErgoBox data_boxes_ptr,
                                                ConstTransactionHintsBagPtr tx_hints_ptr,
                                                TransactionPtr *transaction_out);

/**
 * Adds a new node (above the current level). Hash must be exactly 32 bytes. side represents the side node is on in the tree, 0 = Left, 1 = Right
 */
ErrorPtr ergo_merkle_proof_add_node(MerkleProofPtr proof,
                                    const uint8_t *hash,
                                    uintptr_t hash_len,
                                    uint8_t side);

void ergo_merkle_proof_delete(MerkleProofPtr proof);

/**
 * Deserializes a MerkleProof from its json representation (see /blocks/{headerId}/proofFor/{txId} node api)
 */
ErrorPtr ergo_merkle_proof_from_json(const char *json_str,
                                     MerkleProofPtr *proof_out);

/**
 * Creates a new MerkleProof with given leaf data. Use ergo_merkle_proof_add_node to add levelnodes to the proof. leaf_data must be 32 bytes
 */
ErrorPtr ergo_merkle_proof_new(const uint8_t *leaf_data,
                               uintptr_t len,
                               MerkleProofPtr *proof_out);

/**
 * Serializes a MerkleProof to json representation
 */
ErrorPtr ergo_merkle_proof_to_json(ConstMerkleProofPtr proof, const char **json_str);

/**
 * Checks the merkleproof against the expected root_hash
 */
bool ergo_merkle_proof_valid(ConstMerkleProofPtr proof, const uint8_t *root_hash, uintptr_t len);

/**
 * Checks the merkleproof against a base16 root_hash
 */
ErrorPtr ergo_merkle_proof_valid_base16(ConstMerkleProofPtr proof,
                                        const char *root_hash,
                                        bool *valid);
